/** 
 * 
 */
package io.sarl.hat.airsim.drones.capacities

import fr.utbm.airsim.api.MultirotorState
import fr.utbm.airsim.api.Vector3r
import io.sarl.airsim.simulation.skills.airsim.AirSimMultirotorControl
import io.sarl.airsim.simulation.skills.airsim.AirSimMultirotorSimulationPerception
import io.sarl.airsim.simulation.skills.airsim.AirSimSimulationPerception
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.hat.airsim.drones.IndividualMultirotorControlCapacityWithCallback
import io.sarl.hat.airsim.drones.sr.Area
import io.sarl.hat.airsim.drones.sr.Priority
import io.sarl.lang.core.Agent

/** 
 * @author Sebastian Rodriguez
 * 
 */
skill AirsimIndividualMultirotorControlWithCallback implements IndividualMultirotorControlCapacityWithCallback {
	uses Logging, Schedules

	val control : AirSimMultirotorControl
	val percept : AirSimMultirotorSimulationPerception
	val sim : AirSimSimulationPerception
	val name : String

	new(name : String, ipAddress : String, port : Integer) {
		this.name = name
		control = new AirSimMultirotorControl(ipAddress, port)
		percept = new AirSimMultirotorSimulationPerception(ipAddress, port)
		sim = new AirSimSimulationPerception(ipAddress, port)
	}

	def install {
		this.control.install
	}

	def uninstall {
		this.control.uninstall
	}

	def enableControl {
		this.control.enableControl(this.name)
	}

	def takeOff(callback : (Agent)=>void) {
		execute[
			this.control.takeOff(this.name).join
			callback.apply(owner)
		]

	}

	def land(callback : (Agent)=>void) {
		execute[
			this.control.land(this.name).join
			callback.apply(owner)
		]
	}

	def goHome(callback : (Agent)=>void) {

		execute[
			this.control.goHome(this.name).join
			callback.apply(owner)
		]
	}

	def moveToPosition(x : Float, y : Float, z : Float, velocity : Float, callback : (Agent)=>void) {
		execute[
			while (!inPosition(x, y, z)) {
				this.control.moveToPosition(this.name, x, y, z, velocity).join
				Thread.sleep(500)
				this.enableControl
				say("Waiting to reach position")
				say("Now in " + position)
			}
			callback.apply(owner)
		]
	}

	def getMultirotorState : MultirotorState {
		this.percept.getMultirotorState(this.name)
	}

	def getPosition : Vector3r {
		sim.simGetGroundTruthKinematics(this.name).position
	}

//	def moveByVelocity(vx : Float, vy : Float, vz : Float, duration : Float, callback : (Agent)=>void) {
//		execute[
//			this.control.moveByVelocity(this.name, vx, vy, vz, duration).join
//			callback.apply(owner)
//		]
//	}
//
//	def rotateByYawRate(yawRate : Float, duration : Float, callback : (Agent)=>void) {
//		// FIXME: need to improve the interface to propagate Futures
//		execute[
//			this.control.rotateByYawRate(this.name, yawRate, duration)
//			callback.apply(owner)
//		]
//
//	}
//
//	def rotateToYaw(yaw : Float, callback : (Agent)=>void) {
//		// FIXME: need to improve the interface to propagate Futures
//		execute[
//			this.control.rotateToYaw(this.name, yaw)
//			callback.apply(owner)
//		]
//
//	}

	def inPosition(x : Float, y : Float, z : Float) : boolean {
		val pos = position
		val error = 0.1f
		val area = new Area(x - error, y - error, error * 2, error * 2, Priority.LOW)
		area.contains(pos.x, pos.y) && z >= pos.z - error && y <= pos.z + error
	}

	def say(msg : String) {
		info("[{0}] {1}", this.name, msg)
	}
}
